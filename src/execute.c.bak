#include "minishell.h"

t_pid	execute_command(t_cmd *cmd, int *pipefd)
{
	pid_t	pid;
	int		infd;
	int		outfd;

	pid = fork();
	if (pid < 0)
		ft_perror("fork"); // TODO (E) Leaks
	else if (pid == 0)
	{
		if (cmd->pipe_before)
		{
			dup2(pipefd[0], STDIN_FILENO); // TODO (E) check error
			close(pipefd[0]);
		}
		if (cmd->pipe_after)
		{
			dup2(pipefd[1], STDOUT_FILENO); // TODO (E) check error
			close(pipefd[1]);
		}
		if (cmd->infile != NULL)
		{
			infd = open(cmd->infile, O_RDONLY);
			if (!infd)
				ft_perror("open infile"); // TODO (E) leaks
			if (dup2(infd, STDIN_FILENO) == -1)
				ft_perror("dup infd on stdin"); // TODO (E) leaks
			close(infd);
		}
		if (cmd->outfile != NULL)
		{
			outfd = open(outfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);
			if (!outfd)
				ft_perror("open outfile"); // TODO (E) leaks
			if (dup2(outfd, STDOUT_FILENO) == -1)
				ft_perror("dup outfd on stdout"); // TODO (E) leaks
			close (outfd);	
		}
	}
	// TODO execve here
	return (pid);
}

int	execute_input(t_node *input)
{
	int		*pipefd;
	pid_t	child_pid;
	int		status;

	exec_print_cmd_input(input); // TODO (E) remove (testing)

	while (input != NULL)
	{
		if (input->cmd->pipe_after)
		{
			if (pipe(pipefd) == -1)
				ft_perror("pipe"); // TODO (E) Leaks
		}
		child_pid = execute_command(input->cmd, pipefd);
		waitpid(child_pid, &status, 0);
		if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
			ft_perror("child status"); // TODO leaks
		input = input->next;
	}
	waitpid(child_pid, &status, 0); 	
	return (EXIT_SUCCESS);
}
