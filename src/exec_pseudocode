cmd0 [1]===[0] cmd1 [1]===[0] cmd2

// An error needs to be thrown in parsing part if we we have in t_cmd:
// outfile != NULL AND pipe_after == 1
// OR: infile != NULL AND pipe_before == 1

while (lst)
{
	if (lst->cmd->pipe_after) {
		pipe(fds);
		lst->cmd->fdout = fds[1];
		lst->next->cmd->fdin = fds[0];
	} else {
		if (lst->cmd->infile)
			lst->cmd->fdin = open(lst->cmd->infile, O_RDONLY);
		if (lst->cmd->outfile)
			lst->cmd->fdout = open(lst->cmd->outfile, O_WRONLY | O_CREATE | O_TRUNC, 0644);
	}

	pid = fork();
	if (pid < 0)
		ft_perror("fork");

	if (pid == 0) {
		if (lst->cmd->fdin != -1)
			dup2(lst->cmd->fdin, STDIN_FILENO);
			close(lst->cmd->fdin);
		if (lst->cmd->fdout != -1)
			dup2(lst->cmd->outfd, STDOUT_FILENO);
			close(lst->cmd->fdout);
		if (lst->cmd->pipe_after)
			close(fds[0]);
		// TODO get exec_path
        // ft_join(path, lst->cmd->args[0])
		execve(exec_path, lst->cmd->args, envp);
		ft_perror("execve");
	}

	if (lst->cmd->pipe_after)
		close(fds[1]);
	if (lst->cmd->fdin != -1)
		close(lst->cmd->fdin);
	if (lst->cmd->fdout != -1)
		close(lst->cmd->fdout);
  	
	waitpid(pid, &status, 0);	
  	lst = lst->next;
}
